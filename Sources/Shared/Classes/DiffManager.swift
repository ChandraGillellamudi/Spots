import Foundation

class DiffManager {

  /// Compare two collection of items and generate a `Changes` object that can be used
  /// to update the data source. It supports insertions, deletions, updates, reloads,
  /// child updates and moving items around.
  ///
  /// - Parameters:
  ///   - oldModels: The old collection of items.
  ///   - newModels: The new collection of items.
  /// - Returns: If both a the same, then it returns `nil`, otherwise it returns a `Changes` struct.
  public func compare(oldModels: [Item], newModels: [Item]) -> Changes? {
    guard let itemDiffs = generateItemDiffs(oldModels: oldModels, newItems: newModels) else {
      return nil
    }

    let changes = Changes(changes: itemDiffs)

    return changes
  }

  /// Iterate over two collection of items and determine which operations are appropriate.
  /// If changes are detected in the collection then the method will return a collection
  /// of item diffs. These are generated by `diff` located below.
  ///
  /// - Parameters:
  ///   - oldModels: The old collection of items.
  ///   - newItems: The new collection of items.
  /// - Returns: Will return `nil` if no changes are detected, otherwise a collection of `ItemDiff`s
  private func generateItemDiffs(oldModels: [Item], newItems: [Item]) -> [ItemDiff]? {
    guard oldModels !== newItems else {
      return nil
    }

    var changes = [ItemDiff]()

    if oldModels.count > newItems.count {
      for (index, oldItem) in oldModels.enumerated() {
        if index > newItems.count - 1 {
          changes.append(.removed)
          continue
        }

        let itemDiff = diff(oldItem: oldItem, newItem: newItems[index])

        if let index = newItems.index(where: { $0.compareItemIncludingIndex(oldItem) }), oldItem.index != index {
          changes.append(.move(oldItem.index, index))
        } else {
          changes.append(itemDiff)
        }
      }
    } else if oldModels.count < newItems.count {
      for (index, oldItem) in newItems.enumerated() {
        if index > oldModels.count - 1 {
          changes.append(.new)
          continue
        }

        let diff = oldItem.diff(oldItem)

        if let index = newItems.index(where: { $0.compareItemIncludingIndex(oldItem) }), oldItem.index != index {
          changes.append(.move(oldItem.index, index))
        } else {
          changes.append(diff)
        }
      }
    } else {
      for (index, newItem) in newItems.enumerated() {
        let oldItem = oldModels[index]
        let itemDiff = diff(oldItem: oldItem, newItem: newItem)

        if let index = newItems.index(where: { $0.compareItemIncludingIndex(oldItem) }), oldItem.index != index {
          changes.append(.move(oldItem.index, index))
        } else {
          changes.append(itemDiff)
        }
      }
    }

    return changes
  }

  /// Compare two items and prioritize the update.
  /// When used inside a component reload operation, kind would generate a reload operation
  /// as it would need a new instance of the view. Kind is a direct reference to the view
  /// identifiers. On screen information updates like title, subtitle and text can be applied
  /// as a soft or hard update. Soft update maps the values to the view that is on screen without
  /// telling the data source to reload. Hard updates need to invoke reload on the data source as
  /// that usually means that the size of the item has changed.
  ///
  /// - Parameters:
  ///   - oldItem: The old item
  ///   - newItem: The new item
  /// - Returns: An item diff depending on which attribute changed.
  private func diff(oldItem: Item, newItem: Item) -> ItemDiff {
    let oldChildComponentModels: [ComponentModel] = oldItem.children.map { ComponentModel($0) }
    let newChildComponentModels: [ComponentModel] = newItem.children.map { ComponentModel($0) }

    // Indicates that the view identifier changed, this will later lead to the view
    // being reloaded.
    if newItem.kind != oldItem.kind {
      return .kind
    }

    // Indicates that a composite component inside of the item has been updated.
    if newChildComponentModels !== oldChildComponentModels {
      return .children
    }

    // The items unique identifier has changed which means that the item cannot match.
    if newItem.identifier != oldItem.identifier {
      return .identifier
    }

    if newItem.title != oldItem.title {
      return .title
    }

    if newItem.subtitle != oldItem.subtitle {
      return .subtitle
    }

    if newItem.text != oldItem.text {
      return .text
    }

    if newItem.size != oldItem.size {
      return .size
    }

    if newItem.image != oldItem.image {
      return .image
    }

    if newItem.action != oldItem.action {
      return .action
    }

    if !(newItem.meta as NSDictionary).isEqual(to: oldItem.meta) {
      return .meta
    }

    return .none
  }
}
